// ------------------ event loop ------------------

setTimeout(() => {
  console.log('1 First phase');
}, 1);
setTimeout(() => {
  console.log('2 Second phase');
}, 2);
console.info('3 Third phase');

// 어째서 이러 비 직관적인 결과가 나오는가?
// 1. 메인 자바스크립트 스레드는 AJAX 요청, setTimeout, readFile, 등의 네이티브 비동기 API를 호출한다 (자바스크립트 플랫폼에서 제공하며 만들 수 없다.)
// 2. 비동기 API를 호출하고 메인 스레드는 다시 코드를 계속 실행한다.
// 3. 비동기 API가 완료되면, 플랫폼(이벤트 루프)가 이를 감지하고 Task를 큐에 넣는다. (각 스레드는 자신만의 큐가 있다.)
// 3-1. 태스크에는 호출 자체와 관련된 메타정보 일부, 메인스레드와 연결된 콜백함수의 참조가 포함된다.
// 4. 메인 스레드의 콜스택이 비면, 이벤트 큐에 남아있는 태스크가 있는지 확인한다.
// 4-1-1. if (대기중인 태스크 존재) { 플랫폼은 태스크를 실행한다. }
// 4-1-2. 함수 호출이 일어나며 제어는 메인스레드 함수로 반환된다.(즉, 호출은 메인스레드) -> 함수 호출이 끝나고 콜스택이 비면 플랫폼은 다시 기다리는 태스크가 있는지 이벤트 큐를 확인한다.
// 4-2. if (대기중인 태스크 없음) { 메인스레드는 종료된다. }
// 5. 콜스택과 이벤트 큐가 모두 비고, 모든 비동기 네이티브 API호출이 완료될때까지 반복한다
